{"tagline":"A Small CoffeeScript Object Model for Redis","body":"# Orpheus - Redis Little Helper\r\nOrpheus is a Redis Object Model for CoffeeScript.\r\n\r\n`npm install orpheus`\r\n\r\n- Rails like models\r\n- Sexy DSL\r\n- simple relations\r\n- transactional spirit, with multi\r\n- Dynamic keys\r\n- Maps between strings and ids\r\n- Validations\r\n\r\nIf you are using Orpheus please ping me on [Twitter](http://twitter.com/#!/radagaisus) or [EngineZombie](http://enginezombie.com/). It will make me happy.\r\n\r\n## A Small Taste\r\n```coffee\r\n  class User extends Orpheus\r\n    constructor: ->\r\n      @has 'book'\r\n      \r\n      @str 'about_me'\r\n      @num 'points'\r\n      @set 'likes'\r\n      @zset 'ranking'\r\n      \r\n      @map @str 'fb_id'\r\n      @str 'fb_secret'\r\n  \r\n  user = Player.create()\r\n  \r\n  user('modest')\r\n    .add\r\n      about_me: 'I like douchebags and watermelon'\r\n      points: 5\r\n    .books.add('dune','maybe some proust')\r\n    .err (err) ->\r\n      res.json err.toResponse()\r\n    .exec ->\r\n      # woho!\r\n```\r\n\r\n## Types ##\r\n\r\nOrpheus supports all the basic types of Redis: `@num`, `@str`, `@list`, `@set`, `@zset` and `@hash`. Note that strings and numbers are stored inside the model hash. See the wiki for [supported commands and key names for each type](https://github.com/Radagaisus/Orpheus/wiki).\r\n\r\n## Configuration ##\r\n\r\n```coffee\r\nOrpheus.configure\r\n   client: redis.createClient()\r\n   prefix: 'bookapp'\r\n```\r\n\r\nOptions:\r\n\r\n- **client**: the Redis client.\r\n- **prefix**: optional prefix for keys. defaults to `orpheus`.\r\n\r\n## Issuing Commands with Orpheus\r\n\r\n### The Straightforward Way\r\n\r\n```coffee\r\n  user('rada')\r\n    .name.hset('radagaisus')\r\n    .points.hincrby(5)\r\n    .points_by_time.zincrby(5, new Date().getTime())\r\n    .books.sadd('dune')\r\n```\r\n\r\nNote you don't need to add the command prefix in this cases:\r\n\r\n```coffee\r\nshorthands:\r\n  str: 'h'\r\n  num: 'h'\r\n  list: 'l'\r\n  set: 's'\r\n  zset: 'z'\r\n  hash: 'h'\r\n```\r\n\r\nSo the commands above could have been just `set`, `incrby` and `add`.\r\n\r\n### Adding, Setting, Deleting\r\n\r\n```coffee\r\nuser('dune')\r\n  .add\r\n    points: 20\r\n    ranking: [1, 'best book ever!']\r\n  .set\r\n    name: 'sequel'\r\n  .exec()\r\n```\r\n\r\n```\r\nadd:\r\n\tnum:  'hincrby'\r\n\tstr:  'hset'\r\n\tset:  'sadd'\r\n\tzset: 'zincrby'\r\n\tlist: 'lpush'\r\n\r\nset:\r\n\tnum:  'hset'\r\n\tstr:  'hset'\r\n\tset:  'sadd'\r\n\tzset: 'zadd'\r\n\tlist: 'lpush'\r\n```\r\n\r\n### Getting Stuff\r\n\r\nGetting the entire model in Orpheus is pretty easy:\r\n\r\n```coffee\r\nuser.get (err, user) ->\r\n  res.json user\r\n```\r\n\r\nHere's how get asks for different types:\r\n\r\n```coffee\r\nswitch type\r\n  when 'str', 'num'\r\n    @[key].get()\r\n  when 'list'\r\n    @[key].range 0, -1\r\n  when 'set'\r\n    @[key].members()\r\n  when 'zset'\r\n    @[key].range 0, -1, 'withscores'\r\n  when 'hash'\r\n    @[key].hgetall()\r\n```\r\n\r\nSpecific queries for getting stuff will also convert the response to an object, provided all the commands issued are for getting stuff (no incrby or lpush somewhere in the query).\r\n\r\n```coffee\r\nget_user: (fn) ->\r\n      @name.get()\r\n      @fb_id.get()\r\n      @fb_friends.get()\r\n      @member_since.get()\r\n      @exec fn\r\n```\r\n\r\nConverting to object supports this commands:\r\n\r\n```coffee\r\ngetters: [\r\n  # String, Number\r\n  'hget',\r\n  \r\n  # List\r\n  'lrange',\r\n  \r\n  # Set\r\n  'smembers',\r\n  'scard',\r\n  \r\n  # Zset\r\n  'zrange',\r\n  'zrangebyscore',\r\n  'zrevrange',\r\n  'zrevrangebyscore'\r\n  \r\n  # Hash\r\n  'hget',\r\n  'hgetall',\r\n  'hmget'\r\n]\r\n```\r\n\r\nGetting stuff while updating stuff in the same query will return the results in an array, the same way a Redis multi() command will return the results.\r\n\r\n### Err and Exec\r\n\r\nOrpheus uses the `.err()` function for handling validation and unexpected errors. If `.err()` is not set the `.exec()` command receives errors as the first parameter.\r\n\r\n```coffee\r\nuser('sonic youth')\r\n  .add\r\n    name: 'modest mouse'\r\n    points: 50\r\n  .err (err) ->\r\n    if err.type is 'validation'\r\n      # phew, it's just a validation error\r\n      res.json err.toResponse()\r\n    else\r\n      # Redis Error, or a horrendous\r\n      # bug in Orpheus\r\n      log \"Wake the sysadmins! #{err}\"\r\n      res.json status: 500\r\n  .exec (res, id) ->\r\n    # fun!\r\n```\r\n\r\n**Without Err**:\r\n\r\n```coffee\r\nuser('putin')\r\n  .add\r\n    name: 'putout'\r\n  .exec (err, res, id) ->\r\n    # err is the first parameter\r\n    # everything else as usual\r\n```\r\n\r\n### Separate Callbacks\r\n\r\nJust like with the `multi` command you can supply a separate callback for specific commands.\r\n\r\n```coffee\r\nuser('mgmt')\r\n  .pokemons.push('pikachu', 'charizard', redis.print)\r\n  .err\r\n    -> # ...\r\n  .exec ->\r\n    # ...\r\n```\r\n\r\n### Conditional Commands\r\n\r\nSometimes you'll want to only issue specific commands based on a condition. If you don't want to break the chaining and clutter the code, use `.when(fn)`. `When` executes `fn` immediately, with the context set to the model context. `only` is an alias for `when`.\r\n\r\n```coffee\r\ninfo = get_mission_critical_information()\r\nplayer('danny').when( ->\r\n\tif info is 'nah, never mind' then @name.set('oh YEAHH')\r\n).points.incrby(5) # Business as usual\r\n.exec()\r\n```\r\n\r\n### Relations\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @has 'book'\r\n\r\nclass Book extends Orpheus\r\n  constructor: ->\r\n    @has 'user'\r\n\r\nuser = User.create()\r\nbook = Book.create()\r\n\r\n# Every relation means a set for that relation\r\nuser('chaplin').books.smembers (err, book_ids) ->\r\n  \r\n  # With async functions for fun and profit\r\n  user('chaplin').books.map book_ids, (id, cb, i) ->\r\n      book(id).get cb\r\n    (err, books) ->\r\n      # What? Did we just retrieved all the books from Redis?\r\n```\r\n\r\n## Dynamic Keys\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @zset 'monthly_ranking'\r\n      key: ->\r\n        d = new Date()\r\n        # prefix:user:id:ranking:2012:5\r\n        \"ranking:#{d.getFullYear()}:#{d.getMonth()+1}\"\r\n\r\nuser = User.create()\r\nuser('jackson')\r\n  .monthly_ranking.incrby(1, 'Midnight Oil - The Dead Heart')\r\n  .exec ->\r\n    res.json status: 200\r\n```\r\n\r\nUsing arguments in dyanmic keys is easy:\r\n\r\n```coffee\r\n@zset 'monthly_ranking'\r\n  key: (year, month) ->\r\n    \"ranking:#{year || d.getFullYear()}:#{month || d.getMonth()+1}\"\r\n\r\n# later on, in a far away place...\r\nuser('bean')\r\n  .monthly_ranking.incrby(1, 'Stoned Jesus - I'm The Mountain', key: [2012, 12])\r\n```\r\n\r\nEverything inside `key` will be passed to the dynamic key function.\r\n\r\n\r\n## One to One Maps\r\n\r\nMaps are used to map between a unique attribute of the model and the model ID.\r\n\r\nInternally maps use a hash `prefix:users:map:fb_ids`.\r\n\r\nThis example uses the excellent [PassportJS](passportjs.org).\r\n\r\n```coffee\r\nfb_connect = (req, res, next) ->\r\n  fb = req.account\r\n  fb_details =\r\n    fb_id:    fb.id\r\n    fb_name:  fb.displayName\r\n    fb_token: fb.token\r\n    fb_gener: fb.gender\r\n    fb_url:   fb.profileUrl\r\n  \r\n  id = if req.user then req.user.id else fb_id: fb.id\r\n  player id, (err, player, is_new) ->\r\n    next err if err\r\n    # That's it, we just handled autorization,\r\n    # new users and authentication in one go\r\n    player\r\n      .set(fb_details)\r\n      .exec (err, res, user_id) ->\r\n        req.session.passport.user = user_id if user_id\r\n        next err\r\n```\r\n\r\n#### What Just Happened?\r\n\r\nThere are two scenarios:\r\n\r\n1. **Authentication**: `req.user` is undefined, so the user is not logged in. We create an object `{fb_id: fb.id}` to use in the map. Orpheus requests `hget prefix:users:map:fb_ids fb_id`. If a match is found we continue as usual. Otherwise a new user is created. In both cases, the user's Facebook information is updated.\r\n\r\n2. **Authorization**: `req.user` is defined. The anonymous function is called right away and the user's Facebook information is updated.\r\n\r\n## Validations ##\r\n\r\nValidations are based on the input, not on the object itself. For example, `hincrby 5` will validate the number 5 itself, not the accumulated value in the object.\r\n\r\nValidations run synchronously.\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @str 'name'\r\n    @validate 'name', (s) -> if s is 'something' then true else 'name should be \"something\".'\r\n\r\nplayer = Player.create()\r\nplayer('james').set\r\n  name: 'james!!!'\r\n.err (err) ->\r\n  if err.type is 'validation'\r\n    log err # <OrpheusValidationErrors>\r\n  else\r\n    # something is wrong with redis\r\n.exec (res) ->\r\n  # Never ever land\r\n```\r\n\r\n**OrpheusValidationErrors** has a few convenience functions:\r\n\r\n- **add**: adds an error\r\n- **empty**: clears the errors\r\n- **toResponse**: returns a JSON:\r\n\r\n```coffee\r\n{\r\n  status: 400, # Bad Request\r\n  errors:\r\n    name: ['name should be \"something\".']\r\n}\r\n```\r\n\r\n`errors` contains the actual error objects:\r\n\r\n```coffee\r\n{\r\n  name: [\r\n    msg: 'name should be \"something\".',\r\n    command: 'hset',\r\n    args: ['james!!!'],\r\n    value: 'james!!!',\r\n    date: 1338936463054 # new Date().getTime()\r\n  ],\r\n  # ...\r\n}\r\n```\r\n\r\n### Customizing Message\r\n\r\n```coffee\r\n@validate 'legacy_code',\r\n\tformat: /^[a-zA-Z]+$/\r\n\tmessage: (val) -> \"#{val} must be only A-Za-z\"\r\n```\r\n\r\nWill do the trick. Number validations do not support customized messages yet.\r\n\r\n### Custom Validations ###\r\n\r\n```coffee\r\nclass Player extends Orpheus\r\n\tconstructor: ->\r\n\t\t@str 'name'\r\n\t\t@validate 'name', (s) -> if s is 'babomb' then true else 'String should be babomb.'\r\n```\r\n\r\n### Number Validations ###\r\n\r\n```coffee\r\n@num 'points'\r\n\r\n@validate 'points',\r\n\tnumericality:\r\n\t\tonly_integer: true\r\n\t\tgreater_than: 3\r\n\t\tgreater_than_or_equal_to: 3\r\n\t\tequal_to: 3\r\n\t\tless_than_or_equal_to: 3\r\n\t\todd: true\r\n```\r\n\r\nOptions:\r\n\r\n- **only_integer**: `\"#{n} must be an integer.\"`\r\n- **greater_than**: `\"#{a} must be greater than #{b}.\"`\r\n- **greater_than_or_equal_to**: `\"#{a} must be greater than or equal to #{b}.\"`\r\n- **equal_to**: `\"#{a} must be equal to #{b}.\"`\r\n- **less_than**: `\"#{a} must be less than #{b}.\"`\r\n- **less_than_or_equal_to**: `\"#{a} must be less than or equal to #{b}.\"`\r\n- **odd**: `\"#{a} must be odd.\"`\r\n- **even**: `\"#{a} must be even.\"`\r\n\r\n### Exclusion and Inclusion Validations ###\r\n\r\n```coffee\r\n@str 'subdomain'\r\n@str 'size'\r\n@validate 'subdomain',\r\n\texclusion: ['www', 'us', 'ca', 'jp']\r\n@validate 'size',\r\n\tinclusion: ['small', 'medium', 'large']\r\n```\r\n\r\n### Size ###\r\n\r\n```coffee\r\n@str 'content'\r\n@validate 'content'\r\n\tsize:\r\n\t\ttokenizer: (s) -> s.match(/\\w+/g).length\r\n\t\tis: 5\r\n\t\tminimum: 5\r\n\t\tmaximum: 5\r\n\t\tin: [1,5]\r\n```\r\n\r\nOptions:\r\n\r\n- **minimum**: `\"'#{field}' length is #{len}. Must be bigger than #{min}.`\r\n- **maximum**: `\"'#{field}' length is #{len}. Must be smaller than #{max}.\"`\r\n- **in**: `\"'#{field}' length is #{len}. Must be between #{range[0]} and #{range[1]}.\"`\r\n- **is**: `\"'#{field}' length is #{len1}. Must be #{len2}.\"`\r\n- **tokenizer**: useful for splitting the field in different ways. The default is `field.length`.\r\n\r\n## Regex Validations ##\r\n\r\n```coffee\r\nclass Player extends Orpheus\r\n\tconstructor: ->\r\n\t\t@str 'legacy_code'\r\n\t\t@validate 'legacy_code', format: /^[a-zA-Z]+$/\r\n```\r\n\r\n## Error Handling ##\r\n\r\n- **Undefined Attributes**: Using `set`, `add` and `del` on undefined attributes will throw an error `\"Orpheus :: No Such Model Attribute: #{k}\"`. Trying to `no_such_attribute.incrby(1)` will result in `TypeError: Object #<Object> has no method 'incrby'`. The call stack will directly tell you where the misbehaving attribute sits.\r\n\r\n## Remove a Relationship ##\r\nA dynamic function, called `\"un#{relationship}\"()`, is available for removing already declared relationships. For example, a user with a books relationship will have an `unbook()` function available.\r\n\r\nThis is helpful when trying to abstract away common queries that happen in a lot of requests and denormalize data across relations. Think: points, counters.\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n      constructor: ->\r\n        @has 'issue'\r\n        @num 'comments'\r\n        @num 'email_replies'\r\n\r\n      add_comment: (issue_id) ->\r\n        @comments.incrby 1\r\n        @issue(issue_id)\r\n        @comments.incrby 1\r\n        @unissue()\r\n\r\n\r\n      add_email_reply: (issue_id, fn) ->\r\n        @add_comment issue_id\r\n        @email_replies.incrby 1\r\n        @issue(issue_id)\r\n        @email_replies.incrby 1\r\n        @exec fn\r\n\r\n    user = User.create()\r\n    user('rada').add_email_reply '#142', ->\r\n      # everything went better than expected...\r\n```\r\n\r\n\r\n## Development ##\r\n### Test ###\r\n`cake test`\r\n\r\n### Contribute ###\r\n\r\n- `cake dev`\r\n- Add your tests.\r\n- Do your thing.\r\n- `cake dev`","google":"UA-34452869-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Orpheus"}
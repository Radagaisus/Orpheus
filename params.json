{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A Small CoffeeScript Object Model for Redis","google":"UA-34452869-1","name":"Orpheus","body":"# Orpheus - Redis Little Helper\r\nOrpheus is a Redis Object Model for CoffeeScript.\r\n\r\n`npm install orpheus`\r\n\r\n**Important**: Right now, afaik, Orpheus is only used by our team. If you are using orpheus please ping me on [Twitter](http://twitter.com/#!/radagaisus) or on [EngineZombie](http://enginezombie.com/), so I will know not to come crashing down and add too many breaking changes. The next release will be the last to appear without a Changelog and will be considered stable.\r\n\r\n- Rails like models\r\n- Validations\r\n- Private properties\r\n- simple relations\r\n- transactional spirit, with multi\r\n- Dynamic keys\r\n- Maps between strings and ids\r\n\r\n## A Small Taste\r\n```coffee\r\n  class User extends Orpheus\r\n    constructor: ->\r\n      @has 'book'\r\n      \r\n      @str 'about_me'\r\n      @num 'points'\r\n      @zset 'ranking'\r\n      \r\n      @map @str 'fb_id'\r\n      @private @str 'fb_secret'\r\n  \r\n  user = Player.create()\r\n  \r\n  user('modest')\r\n    .add\r\n      about_me: 'I like douchebags and watermelon'\r\n      points: 5\r\n    .books.add('dune','maybe some proust')\r\n    .err (err) ->\r\n      res.json err.toResponse()\r\n    .exec ->\r\n      # woho!\r\n```\r\n\r\n## Configuration ##\r\n\r\n```coffee\r\nOrpheus.configure\r\n   client: redis.createClient()\r\n   prefix: 'bookapp'\r\n```\r\n\r\nOptions:\r\n\r\n- **client**: the Redis client.\r\n- **prefix**: optional prefix for keys. defaults to `orpheus`.\r\n\r\n## Working with the API\r\n\r\n### Add, Set\r\n\r\n```coffee\r\nuser('dune')\r\n  .add\r\n    points: 20\r\n    ranking: [1, 'best book ever!']\r\n  .set\r\n    name: 'sequel'\r\n  .exec()\r\n```\r\n\r\n```\r\nadd:\r\n\tnum:  'hincrby'\r\n\tstr:  'hset'\r\n\tset:  'sadd'\r\n\tzset: 'zincrby'\r\n\tlist: 'lpush'\r\n\r\nset:\r\n\tnum:  'hset'\r\n\tstr:  'hset'\r\n\tset:  'sadd'\r\n\tzset: 'zadd'\r\n\tlist: 'lpush'\r\n```\r\n\r\n### Err and Exec\r\n\r\nOrpheus uses the `.err()` function for handling validation and unexpected errors. If `.err()` is not set the `.exec()` command receives errors as the first parameter.\r\n\r\n```coffee\r\nuser('sonic youth')\r\n  .add\r\n    name: 'modest mouse'\r\n    points: 50\r\n  .err (err) ->\r\n    if err.type is 'validation'\r\n      # phew, it's just a validation error\r\n      res.json err.toResponse()\r\n    else\r\n      # Redis Error, or a horrendous\r\n      # bug in Orpheus\r\n      log \"Wake the sysadmins! #{err}\"\r\n      res.json status: 500\r\n  .exec (res, id) ->\r\n    # fun!\r\n```\r\n\r\n**Without Err**:\r\n\r\n```coffee\r\nuser('putin')\r\n  .add\r\n    name: 'putout'\r\n  .exec (err, res, id) ->\r\n    # err is the first parameter\r\n    # everything else as usual\r\n```\r\n\r\n### Separate Callbacks\r\n\r\nJust like with the `multi` command you can supply a separate callback for specific commands.\r\n\r\n```coffee\r\nuser('mgmt')\r\n  .pokemons.push('pikachu', 'charizard', redis.print)\r\n  .err\r\n    -> # ...\r\n  .exec ->\r\n    # ...\r\n```\r\n\r\n### Conditional Commands\r\n\r\nSometimes you'll want to only issue specific commands based on a condition. If you don't want to break the chaining and clutter the code, use `.when(fn)`. `When` executes `fn` immediately, with the context set to the model context. `Only` is an alias for `when`.\r\n\r\n```coffee\r\ninfo = get_mission_critical_information()\r\nplayer('danny').when( ->\r\n\tif info is 'nah, never mind' then @name.set('oh YEAHH')\r\n).points.incrby(5) # Business as usual\r\n.exec()\r\n```\r\n\r\n### Relations\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @has 'book'\r\n\r\nclass Book extends Orpheus\r\n  constructor: ->\r\n    @has 'user'\r\n\r\nuser = User.create()\r\nbook = Book.create()\r\n\r\n# Every relation means a set for that relation\r\nuser('chaplin').books.smembers (err, book_ids) ->\r\n  \r\n  # With async functions for fun and profit\r\n  user('chaplin').books.map book_ids, (id, cb, i) ->\r\n      book(id).get cb\r\n    (err, books) ->\r\n      # What? Did we just retrieved all the books from Redis?\r\n```\r\n\r\n## Dynamic Keys\r\n\r\n```\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @zset 'monthly_ranking'\r\n      key: ->\r\n        d = new Date()\r\n        # prefix:user:id:ranking:2012:5\r\n        \"ranking:#{d.getFullYear()}:#{d.getMonth()+1}\"\r\n\r\nuser = User.create()\r\nuser('jackson')\r\n  .monthly_ranking.incrby(1, 'Midnight Oil - The Dead Heart')\r\n  .err ->\r\n    res.json status: 400\r\n  .exec ->\r\n    res.json status: 200\r\n```\r\n\r\n## One to One Maps\r\n\r\nMaps are used to map between a unique attribute of the model and the model ID.\r\n\r\nInternally maps use a hash `prefix:users:map:fb_ids`.\r\n\r\nThis example uses the excellent [PassportJS](passportjs.org).\r\n\r\n```coffee\r\nfb_connect = (req, res, next) ->\r\n  fb = req.account\r\n  fb_details =\r\n    fb_id:    fb.id\r\n    fb_name:  fb.displayName\r\n    fb_token: fb.token\r\n    fb_gener: fb.gender\r\n    fb_url:   fb.profileUrl\r\n  \r\n  id = if req.user then req.user.id else fb_id: fb.id\r\n  player id, (err, player, is_new) ->\r\n    next err if err\r\n    # That's it, we just handled autorization,\r\n    # new users and authentication in one go\r\n    player\r\n      .set(fb_details)\r\n      .exec (err, res, user_id) ->\r\n        req.session.passport.user = user_id if user_id\r\n        next err\r\n```\r\n\r\n#### What Just Happened?\r\n\r\nThere are two scenarios:\r\n\r\n1. **Authentication**: `req.user` is undefined, so the user is not logged in. We create an object `{fb_id: fb.id}` to use in the map. Orpheus requests `hget prefix:users:map:fb_ids fb_id`. If a match is found we continue as usual. Otherwise a new user is created. In both cases, the user's Facebook information is updated.\r\n\r\n2. **Authorization**: `req.user` is defined. The anonymous function is called right away and the user's Facebook information is updated.\r\n\r\n## Validations ##\r\n\r\nValidations are based on the input, not on the object itself. For example, `hincrby 5` will validate the number 5 itself, not the accumulated value in the object.\r\n\r\nValidations run synchronously.\r\n\r\n```coffee\r\nclass User extends Orpheus\r\n  constructor: ->\r\n    @str 'name'\r\n    @validate 'name', (s) -> if s is 'something' then true else 'name should be \"something\".'\r\n\r\nplayer = Player.create()\r\nplayer('james').set\r\n  name: 'james!!!'\r\n.err (err) ->\r\n  if err.type is 'validation'\r\n    log err # <OrpheusValidationErrors>\r\n  else\r\n    # something is wrong with redis\r\n.exec (res) ->\r\n  # Never ever land\r\n```\r\n\r\n**OrpheusValidationErrors** has a few convenience functions:\r\n\r\n- **add**: adds an error\r\n- **empty**: clears the errors\r\n- **toResponse**: returns a JSON:\r\n\r\n```coffee\r\n{\r\n  status: 400, # Bad Request\r\n  errors:\r\n    name: ['name should be \"something\".']\r\n}\r\n```\r\n\r\n`errors` contains the actual error objects:\r\n\r\n```coffee\r\n{\r\n  name: [\r\n    msg: 'name should be \"something\".',\r\n    command: 'hset',\r\n    args: ['james!!!'],\r\n    value: 'james!!!',\r\n    date: 1338936463054 # new Date().getTime()\r\n  ],\r\n  # ...\r\n}\r\n```\r\n\r\n### Customizing Message\r\n\r\n```coffee\r\n@validate 'legacy_code',\r\n\tformat: /^[a-zA-Z]+$/\r\n\tmessage: (val) -> \"#{val} must be only A-Za-z\"\r\n```\r\n\r\nWill do the trick. Number validations do not support customized messages yet.\r\n\r\n### Custom Validations ###\r\n\r\n```coffee\r\nclass Player extends Orpheus\r\n\tconstructor: ->\r\n\t\t@str 'name'\r\n\t\t@validate 'name', (s) -> if s is 'babomb' then true else 'String should be babomb.'\r\n```\r\n\r\n### Number Validations ###\r\n\r\n```coffee\r\n@num 'points'\r\n\r\n@validate 'points',\r\n\tnumericality:\r\n\t\tonly_integer: true\r\n\t\tgreater_than: 3\r\n\t\tgreater_than_or_equal_to: 3\r\n\t\tequal_to: 3\r\n\t\tless_than_or_equal_to: 3\r\n\t\todd: true\r\n```\r\n\r\nOptions:\r\n\r\n- **only_integer**: `\"#{n} must be an integer.\"`\r\n- **greater_than**: `\"#{a} must be greater than #{b}.\"`\r\n- **greater_than_or_equal_to**: `\"#{a} must be greater than or equal to #{b}.\"`\r\n- **equal_to**: `\"#{a} must be equal to #{b}.\"`\r\n- **less_than**: `\"#{a} must be less than #{b}.\"`\r\n- **less_than_or_equal_to**: `\"#{a} must be less than or equal to #{b}.\"`\r\n- **odd**: `\"#{a} must be odd.\"`\r\n- **even**: `\"#{a} must be even.\"`\r\n\r\n### Exclusion and Inclusion Validations ###\r\n\r\n```coffee\r\n@str 'subdomain'\r\n@str 'size'\r\n@validate 'subdomain',\r\n\texclusion: ['www', 'us', 'ca', 'jp']\r\n@validate 'size',\r\n\tinclusion: ['small', 'medium', 'large']\r\n```\r\n\r\n### Size ###\r\n\r\n```coffee\r\n@str 'content'\r\n@validate 'content'\r\n\tsize:\r\n\t\ttokenizer: (s) -> s.match(/\\w+/g).length\r\n\t\tis: 5\r\n\t\tminimum: 5\r\n\t\tmaximum: 5\r\n\t\tin: [1,5]\r\n```\r\n\r\nOptions:\r\n\r\n- **minimum**: `\"'#{field}' length is #{len}. Must be bigger than #{min}.`\r\n- **maximum**: `\"'#{field}' length is #{len}. Must be smaller than #{max}.\"`\r\n- **in**: `\"'#{field}' length is #{len}. Must be between #{range[0]} and #{range[1]}.\"`\r\n- **is**: `\"'#{field}' length is #{len1}. Must be #{len2}.\"`\r\n- **tokenizer**: useful for splitting the field in different ways. The default is `field.length`.\r\n\r\n## Regex Validations ##\r\n\r\n```coffee\r\nclass Player extends Orpheus\r\n\tconstructor: ->\r\n\t\t@str 'legacy_code'\r\n\t\t@validate 'legacy_code', format: /^[a-zA-Z]+$/\r\n```\r\n\r\n## Development ##\r\n### Test ###\r\n`cake test`\r\n\r\n### Contribute ###\r\n\r\n- `cake dev`\r\n- Add your tests.\r\n- Do your thing.\r\n- `cake dev`\r\n\r\n## Roadmap ##\r\n\r\n- Validations\r\n- Promises "}
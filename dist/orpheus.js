// Generated by CoffeeScript 1.9.2
(function() {
  var Orpheus, OrpheusAPI, OrpheusValidationErrors, _, async, clone, command_map, commands, getters, inflector, os, validation_map, validations,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  _ = require('underscore');

  async = require('async');

  os = require('os');

  clone = require('clone');

  inflector = require('./inflector');

  commands = require('./commands');

  validations = require('./validations');

  command_map = commands.command_map;

  validation_map = commands.validations;

  getters = commands.getters;

  Orpheus = (function() {
    function Orpheus() {}

    Orpheus.version = require('../package.json').version;

    Orpheus.config = {
      prefix: 'orpheus'
    };

    Orpheus.configure = function(o) {
      return this.config = _.extend(this.config, o);
    };

    Orpheus.schema = {};

    Orpheus.id_counter = 0;

    Orpheus.unique_id = function() {
      return this.id_counter++;
    };

    Orpheus.connect = function(models, callback) {
      var model, model_commands, model_name, multi_commands, schema;
      schema = {};
      multi_commands = [];
      for (model_name in models) {
        model = models[model_name];
        model_commands = model._commands;
        schema[model_name] = model_commands.length;
        multi_commands = multi_commands.concat(model_commands);
      }
      return Orpheus.config.client.multi(multi_commands).exec(function(err, results) {
        var key, num, response;
        if (err) {
          return callback(err, results = []);
        } else {
          response = {};
          for (key in schema) {
            num = schema[key];
            response[key] = results.splice(0, num);
          }
          return callback(err, response);
        }
      });
    };

    Orpheus.create = function() {
      var OrpheusModel, model, name, q;
      OrpheusModel = (function(superClass) {
        extend(OrpheusModel, superClass);

        function OrpheusModel(name1, q1) {
          var f, j, len1, ref;
          this.name = name1;
          this.q = q1;
          this.id = bind(this.id, this);
          this.redis = Orpheus.config.client;
          this.prefix = Orpheus.config.prefix;
          this.pname = inflector.pluralize(this.name);
          this.model = {};
          this.rels = [];
          this.rels_qualifiers = [];
          this.validations = [];
          this.fields = ['str', 'num', 'list', 'set', 'zset', 'hash'];
          ref = this.fields;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            f = ref[j];
            this.create_field(f);
          }
          OrpheusModel.__super__.constructor.call(this);
        }

        OrpheusModel.prototype.create_field = function(f) {
          return this[f] = function(field, options) {
            if (options == null) {
              options = {};
            }
            if (this.model[field]) {
              throw new Error("Field name already taken");
            }
            this.model[field] = {
              type: f,
              options: options
            };
            return field;
          };
        };

        OrpheusModel.prototype.map = function(field) {
          if (this.model[field].type !== 'str') {
            throw new Error("Map only works on strings");
          }
          return this.model[field].options.map = true;
        };

        OrpheusModel.prototype.has = function(rel, options) {
          var qualifier;
          if (options == null) {
            options = {};
          }
          qualifier = options.namespace || rel.substr(0, 2);
          this.rels.push(rel);
          this.rels_qualifiers.push(qualifier);
          this[rel] = function(id) {
            this[qualifier + "_id"] = this[rel + "_id"] = id;
            return this;
          };
          return this['un' + rel] = function() {
            this[qualifier + "_id"] = this[rel + "_id"] = null;
            return this;
          };
        };

        OrpheusModel.prototype.validate = function(key, o) {
          var base, fn1, k, ref, ref1, results1, tokenizer, v;
          (base = this.validations)[key] || (base[key] = []);
          if (_.isFunction(o)) {
            return this.validations[key].push(o);
          } else {
            if (o.numericality) {
              ref = o.numericality;
              fn1 = (function(_this) {
                return function(k, v) {
                  return _this.validations[key].push(function(field) {
                    if (!validations.num[k].fn(field, v)) {
                      return validations.num[k].msg(field, v);
                    }
                    return true;
                  });
                };
              })(this);
              for (k in ref) {
                v = ref[k];
                fn1(k, v);
              }
            }
            if (o.exclusion) {
              this.validations[key].push(function(field) {
                if (indexOf.call(o.exclusion, field) >= 0) {
                  if (o.message) {
                    return o.message(field);
                  } else {
                    return field + " is reserved.";
                  }
                }
                return true;
              });
            }
            if (o.inclusion) {
              this.validations[key].push(function(field) {
                if (indexOf.call(o.inclusion, field) >= 0) {
                  return true;
                }
                if (o.message) {
                  return o.message(field);
                } else {
                  return field + " is not included in the list.";
                }
              });
            }
            if (o.format) {
              this.validations[key].push(function(field) {
                if (o.format.test(field)) {
                  return true;
                }
                if (o.message) {
                  return o.message(field);
                } else {
                  return field + " is invalid.";
                }
              });
            }
            if (o.size) {
              tokenizer = o.size.tokenizer || function(field) {
                return field.length;
              };
              ref1 = o.size;
              results1 = [];
              for (k in ref1) {
                v = ref1[k];
                results1.push((function(_this) {
                  return function(k, v) {
                    if (k === 'tokenizer') {
                      return;
                    }
                    return _this.validations[key].push(function(field) {
                      var len;
                      len = tokenizer(field);
                      if (!validations.size[k].fn(len, v)) {
                        return validations.size[k].msg(field, len, v);
                      }
                      return true;
                    });
                  };
                })(this)(k, v));
              }
              return results1;
            }
          }
        };

        OrpheusModel.prototype.id = function(id, fn) {
          var key, message, name, new_model, plural_name, results1, value;
          if (!id || _.isString(id) || _.isNumber(id)) {
            if (fn) {
              new_model = new OrpheusAPI(id, this);
              return fn(null, new_model, new_model.id, false);
            } else {
              return new OrpheusAPI(id, this);
            }
          } else if (_.isObject(id) && fn) {
            results1 = [];
            for (name in id) {
              value = id[name];
              plural_name = inflector.pluralize(name);
              key = this.prefix + ":" + this.pname + ":map:" + plural_name;
              results1.push(this.redis.hget(key, value, (function(_this) {
                return function(err, model_id) {
                  if (err) {
                    return fn(err);
                  }
                  if (model_id) {
                    new_model = new OrpheusAPI(model_id, _this);
                    return fn(null, new_model, model_id, false);
                  } else {
                    new_model = new OrpheusAPI(null, _this);
                    new_model._add_map(plural_name, value);
                    return fn(null, new_model, new_model.id, true);
                  }
                };
              })(this)));
            }
            return results1;
          } else {
            message = "Orpheus Model must be instantiated with a proper id";
            throw new Error(message);
          }
        };

        return OrpheusModel;

      })(this);
      name = this.toString().match(/function (.*)\(/)[1].toLowerCase();
      q = name.substr(0, 2);
      model = new OrpheusModel(name, q);
      Orpheus.schema[name] = model.id;
      return model.id;
    };

    return Orpheus;

  })();

  OrpheusAPI = (function() {
    function OrpheusAPI(id, model1) {
      var f, fn1, fn2, j, key, l, len1, len2, len3, len4, len5, n, p, prel, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, rel, value;
      this.model = model1;
      this._create_getter_object = bind(this._create_getter_object, this);
      _.extend(this, this.model);
      this._commands = [];
      this.flags = {};
      this.validation_errors = new OrpheusValidationErrors;
      this._res_schema = [];
      this.id = id || this._generate_id();
      this.only = this.when = (function(_this) {
        return function(condition, fn) {
          if (fn == null) {
            fn = condition;
          }
          if (condition) {
            fn.bind(_this)();
          }
          return _this;
        };
      })(this);
      ref = this.rels;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        rel = ref[j];
        prel = inflector.pluralize(rel);
        this.model[prel] = {
          type: 'set',
          options: {}
        };
        this[prel] = {};
      }
      ref1 = this.model;
      fn1 = (function(_this) {
        return function(key) {
          _this[key].key = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            _this[key]._key_arguments = args;
            return _this[key];
          };
          return _this[key].as = function(key_name) {
            _this[key]._key_name = key_name;
            return _this[key];
          };
        };
      })(this);
      for (key in ref1) {
        value = ref1[key];
        this[key] = {};
        ref2 = commands[value.type];
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          f = ref2[l];
          this._create_command(key, value, f);
        }
        if ((ref3 = value.type) === 'set' || ref3 === 'zset' || ref3 === 'hash' || ref3 === 'list') {
          ref4 = commands.keys;
          for (n = 0, len3 = ref4.length; n < len3; n++) {
            f = ref4[n];
            this._create_command(key, value, f);
          }
        }
        fn1(key);
      }
      ref5 = this.rels;
      fn2 = (function(_this) {
        return function(rel, prel) {
          var k, ref6, results1, v;
          _this[prel].map = function(arr, iter, done) {
            var i;
            if (arr == null) {
              arr = [];
            }
            i = 0;
            return async.map(arr, function(item, cb) {
              return iter(item, cb, i++);
            }, done);
          };
          results1 = [];
          for (k in async) {
            v = async[k];
            if ((ref6 = !k) === 'map' || ref6 === 'noConflict') {
              results1.push(_this[prel][k] = v);
            }
          }
          return results1;
        };
      })(this);
      for (p = 0, len4 = ref5.length; p < len4; p++) {
        rel = ref5[p];
        prel = inflector.pluralize(rel);
        fn2(rel, prel);
      }
      ref6 = ['add', 'set'];
      for (r = 0, len5 = ref6.length; r < len5; r++) {
        f = ref6[r];
        this._add_op(f);
      }
    }

    OrpheusAPI.prototype._create_command = function(key, value, f) {
      var type;
      type = value.type;
      this[key][f] = (function(_this) {
        return function() {
          var args, dynamic_key_args, field, j, key_name, len1, ref, result, v;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (_.isObject(args[args.length - 1]) && args[args.length - 1].key) {
            dynamic_key_args = args.pop().key;
          }
          field = args[0];
          if (validation_map[f]) {
            if (type === 'str') {
              if (!_.isString(field)) {
                if (_.isNumber(field)) {
                  field = field.toString();
                } else {
                  _this.validation_errors.add(key, {
                    msg: "Could not convert " + key + " to string",
                    command: f,
                    args: args,
                    value: field
                  });
                  return _this;
                }
              }
            }
            if (type === 'num') {
              if (!_.isNumber(field)) {
                field = Number(field);
              }
              if (!isFinite(field) || isNaN(field)) {
                _this.validation_errors.add(key, {
                  msg: "Malformed number",
                  command: f,
                  args: args,
                  value: field
                });
                return _this;
              }
            }
          }
          _this._commands.push(_.flatten([f, _this._get_key(key, dynamic_key_args), args]));
          key_name = _this[key]._key_name;
          delete _this[key]._key_name;
          if (indexOf.call(getters, f) >= 0) {
            _this._res_schema.push({
              type: type,
              name: key,
              key_name: key_name,
              dynamic_key_args: dynamic_key_args,
              with_scores: type === 'zset' && indexOf.call(args, 'withscores') >= 0
            });
          }
          if (validation_map[f] && _this.validations[key]) {
            if (type === 'str' || type === 'num') {
              ref = _this.validations[key];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                v = ref[j];
                result = v.apply(null, args);
                if (result !== true) {
                  _this.validation_errors.add(key, {
                    msg: result,
                    command: f,
                    args: args,
                    value: args[0]
                  });
                }
              }
              if (!_this.validation_errors.valid()) {
                return _this;
              }
            }
          }
          if (_this.model[key].options.map) {
            _this._extra_commands(key, f, args);
          }
          return _this;
        };
      })(this);
      if (f[0] === commands.shorthands[value.type]) {
        return this[key][f.slice(1)] = this[key][f];
      }
    };

    OrpheusAPI.prototype._add_op = function(f) {
      return this[f] = function(o) {
        var command, k, type, v;
        for (k in o) {
          v = o[k];
          if (typeof this.model[k] === 'undefined') {
            throw new Error("Orpheus :: No Such Model Attribute: " + k);
          }
          type = this.model[k].type;
          command = command_map[f][type];
          this[k][command](v);
        }
        return this;
      };
    };

    OrpheusAPI.prototype._generate_id = function() {
      var counter, host, j, len1, pid, random, ref, s, time;
      this._new_id = true;
      time = "" + (new Date().getTime());
      pid = process.pid;
      host = 0;
      ref = os.hostname();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        s = ref[j];
        host += s.charCodeAt(0);
      }
      counter = Orpheus.unique_id();
      random = Math.round(Math.random() * 1000);
      return "" + host + pid + time + counter + random;
    };

    OrpheusAPI.prototype._get_key = function(key, dynamic_key_args) {
      var j, k, len1, ref, rel, type;
      k = this.prefix + ":" + this.q + ":" + this.id;
      ref = this.rels_qualifiers;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        rel = ref[j];
        if (this[rel + "_id"]) {
          k += (":" + rel + ":") + this[rel + "_id"];
        }
      }
      if (!key) {
        return k;
      }
      type = this.model[key].type;
      if (key && this.model[key].options.key) {
        if (dynamic_key_args) {
          if (!_.isArray(dynamic_key_args)) {
            dynamic_key_args = [dynamic_key_args];
          }
        } else {
          dynamic_key_args = this[key]._key_arguments;
        }
        key = this.model[key].options.key.apply(this, dynamic_key_args);
      }
      if (type === 'str' || type === 'num') {
        return [k, key];
      } else {
        return k + ":" + key;
      }
    };

    OrpheusAPI.prototype._add_map = function(field, key) {
      return this._commands.push(['hset', this.prefix + ":" + this.pname + ":map:" + field, key, this.id]);
    };

    OrpheusAPI.prototype._extra_commands = function(key, command, args) {
      var pkey;
      if (this.model[key].options.map && command === 'hset') {
        pkey = inflector.pluralize(key);
        return this._add_map(pkey, args[0]);
      }
    };

    OrpheusAPI.prototype.flush = function() {
      this._commands = [];
      this.validation_errors.empty();
      return this._res_schema = [];
    };

    OrpheusAPI.prototype["delete"] = function() {
      var hdel_flag, key, ref, type, value;
      hdel_flag = false;
      ref = this.model;
      for (key in ref) {
        value = ref[key];
        type = value.type;
        if (type === 'str' || type === 'num') {
          if (!hdel_flag) {
            hdel_flag = true;
            this._commands.push(['del', this._get_key()]);
          }
        } else {
          this._commands.push(['del', this._get_key(key)]);
        }
      }
      return this;
    };

    OrpheusAPI.prototype.get = function(fn) {
      var key, ref, type, value;
      ref = this.model;
      for (key in ref) {
        value = ref[key];
        type = value.type;
        switch (type) {
          case 'str':
          case 'num':
            this[key].get();
            break;
          case 'list':
            this[key].range(0, -1);
            break;
          case 'set':
            this[key].members();
            break;
          case 'zset':
            this[key].range(0, -1, 'withscores');
            break;
          case 'hash':
            this[key].hgetall();
        }
      }
      return this.exec(fn);
    };

    OrpheusAPI.prototype._create_getter_object = function(res) {
      var dynamic_key, field, i, index, j, l, len1, len2, len3, member, n, nesting, new_res, ref, ref1, s, temp_res, tmp, traversal, zset;
      new_res = {};
      temp_res = {};
      ref = this._res_schema;
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        s = ref[i];
        if (s.type === 'num') {
          res[i] = Number(res[i]);
        } else if (s.type === 'zset' && s.with_scores) {
          zset = {};
          ref1 = res[i];
          for (index = l = 0, len2 = ref1.length; l < len2; index = l += 2) {
            member = ref1[index];
            zset[member] = Number(res[i][index + 1]);
          }
          res[i] = zset;
        }
        if (s.key_name) {
          traversal = s.key_name.split('.');
          for (index = n = 0, len3 = traversal.length; n < len3; index = ++n) {
            nesting = traversal[index];
            tmp = tmp || new_res;
            if (index + 1 === traversal.length) {
              tmp[nesting] = res[i];
            } else {
              tmp[nesting] || (tmp[nesting] = {});
            }
            tmp = tmp[nesting];
          }
        } else if (this.model[s.name].options.key) {
          if (temp_res[s.name] == null) {
            temp_res[s.name] = res[i];
            temp_res[s.name + "_key"] = this.model[s.name].options.key.apply(this, s.dynamic_key_args);
          } else {
            dynamic_key = temp_res[s.name + "_key"];
            if (dynamic_key) {
              tmp = temp_res[s.name];
              temp_res[s.name] = {};
              temp_res[s.name][dynamic_key] = tmp;
              delete temp_res[s.name + "_key"];
            }
            dynamic_key = this.model[s.name].options.key.apply(this, s.dynamic_key_args);
            temp_res[s.name][dynamic_key] = res[i];
          }
          new_res[s.name] = temp_res[s.name];
        } else if (new_res[s.name] != null) {
          if (temp_res[s.name] != null) {
            temp_res[s.name].push(res[i]);
          } else {
            temp_res[s.name] = [new_res[s.name], res[i]];
          }
          new_res[s.name] = temp_res[s.name];
        } else {
          new_res[s.name] = res[i];
        }
        field = new_res[s.name];
        if (_.isNull(field) || _.isUndefined(field) || (_.isObject(field) && _.isEmpty(field))) {
          if (_.isUndefined(this.model[s.name].options["default"])) {
            delete new_res[s.name];
          } else {
            new_res[s.name] = clone(this.model[s.name].options["default"]);
          }
        }
      }
      return new_res;
    };

    OrpheusAPI.prototype.raw = function() {
      this.flags.raw_response = true;
      return this;
    };

    OrpheusAPI.prototype.err = function(fn) {
      this.error_func = fn || function() {};
      return this;
    };

    OrpheusAPI.prototype.exec = function(fn) {
      fn || (fn = function() {});
      if (this.validation_errors.invalid()) {
        if (this.error_func) {
          return this.error_func(this.validation_errors, this.id);
        } else {
          return fn(this.validation_errors, null, this.id);
        }
      }
      return this.redis.multi(this._commands).exec((function(_this) {
        return function(err, res) {
          if (_this._res_schema.length && !err) {
            if (_this._res_schema.length === _this._commands.length) {
              if (!_this.flags.raw_response) {
                res = _this._create_getter_object(res);
              }
            }
          }
          if (_this.error_func) {
            if (err) {
              err.time = new Date();
              err.level = 'ERROR';
              err.type = 'redis';
              err.msg = 'Failed Multi Execution';
              _this._errors.push(err);
              Orpheus.emit('error', err);
              return _this.error_func(err);
            } else {
              if (_this._new_id) {
                return fn(res, _this.id);
              } else {
                return fn(res);
              }
            }
          } else {
            if (_this._new_id) {
              return fn(err, res, _this.id);
            } else {
              return fn(err, res);
            }
          }
        };
      })(this));
    };

    return OrpheusAPI;

  })();

  OrpheusValidationErrors = (function() {
    function OrpheusValidationErrors() {
      this.type = 'validation';
      this.errors = {};
    }

    OrpheusValidationErrors.prototype.valid = function() {
      return _.isEmpty(this.errors);
    };

    OrpheusValidationErrors.prototype.invalid = function() {
      return !this.valid();
    };

    OrpheusValidationErrors.prototype.add = function(field, error) {
      var base;
      error.date = new Date().getTime();
      (base = this.errors)[field] || (base[field] = []);
      return this.errors[field].push(error);
    };

    OrpheusValidationErrors.prototype.empty = function() {
      return this.errors = {};
    };

    OrpheusValidationErrors.prototype.toResponse = function() {
      var k, m, obj, ref, v;
      obj = {
        status: 400,
        errors: {}
      };
      ref = this.errors;
      for (k in ref) {
        v = ref[k];
        obj.errors[k] = (function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = v.length; j < len1; j++) {
            m = v[j];
            results1.push(m.msg);
          }
          return results1;
        })();
      }
      return obj;
    };

    return OrpheusValidationErrors;

  })();

  module.exports = Orpheus;

}).call(this);
